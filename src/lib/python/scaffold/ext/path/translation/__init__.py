#
# Copyright 2014-2024 Justin Ottley
#
# Licensed under the terms set forth in the LICENSE.txt file
#

import os
import sys
import socket
import pprint
import logging
import traceback

from .. import util as pathutil

LOG = logging.getLogger(__name__)

TRANSLATION_CONFIG = []


class TranslationConfig(object):

    def __init__(self, name, translation_map, validate_func, enabled=True):

        self.name = name
        self.translation_map = translation_map
        self.validate_func = validate_func

        self.__enabled = enabled

    def __str__(self):
        return '<{}.{} "{}" at {}>'.format(
            self.__class__.__module__,
            self.__class__.__name__,
            self.name,
            hex(id(self))
        )

    def __repr__(self):
        return str(self)


    @property
    def enabled(self):
        return self.__enabled

    def set_enabled(self, is_enabled):
        self.__enabled = is_enabled
    
    def set_entry_enabled(self, entry_name, is_enabled):
        for tmap_entry in self.translation_map:
            if tmap_entry['name'] == entry_name:
                tmap_entry['enabled'] = is_enabled
                break


    def is_entry_enabled(self, entry):

        result = True
        for tmap_entry in self.translation_map:
            if 'enabled' in tmap_entry:
                result = tmap_entry['enabled']

        return result


    def enable(self):
        return self.set_enabled(True)

    def disable(self):
        return self.set_enabled(False)


def set_config_enabled(name, entry, is_enabled):

    config_set = False

    # LOG.log(9, 'set_config_enabled {} {} {}'.format(name, entry, is_enabled))
    
    for config_obj in TRANSLATION_CONFIG:
        if config_obj.name == name:

            if entry is None:
                config_obj.set_enabled(is_enabled)

                LOG.debug('Setting config "{}" enabled: {}'.format(name, is_enabled))
                config_set = True

            else:
                config_obj.set_entry_enabled(entry, is_enabled)

                LOG.debug('Setting config entry "{}.{}" enabled: {}'.format(name, entry, is_enabled))
                config_set = True

            break
    
    else:
        LOG.warning('Config not set: {}'.format(name))

    return config_set


def get_config(config_name):

    for config_obj in TRANSLATION_CONFIG:
        if config_obj.name == config_name:
            return config_obj



def get_frozen_translation_map(apps=False):

    # NOTE: late import
    from .. import Path

    result = []
    
    uri_list = []

    # 'apps' # Don't freeze apps, fallback to use network path? TODO FIXME: hack?
    # 'thirdparty', # Don't freeze thirdparty, fallback to use network path? TODO FIXME: hack?
    if apps:
        uri_list.append('apps')

    uri_list.extend([
        'thirdparty_network',
        'dist',
        'local_users'
    ])

    for uri_name in uri_list:

        uri_entry = '{}://'.format(uri_name)
        tmap_entry = {'name': uri_name}
        mapping = {'URI': [uri_name]}

        for path_format in ['DriveLetter', 'UNC', 'Posix']:

            # TODO FIXME HACK FOR FREEZING apps - set UNC anchor to drive letter to get around freezing
            # the hostname of the submitting user. THere needs to be a way of substituting the hostname
            # of the current machine, but that is not available
            #
            if uri_name == 'apps' and path_format == 'UNC':
                mapping[path_format] = [
                    Path(uri_entry).format('DriveLetter', force_validate=True)
                ]

            else:
                mapping[path_format] = [
                    Path(uri_entry).format(path_format, force_validate=True)
                ]


        tmap_entry['mapping'] = mapping
        result.append(tmap_entry)

    return result


def get_frozen_translation_config(dest_dir, apps=False):

    config_contents = '#\n# Translation config automatically generated by scaffold\n#\n\n'
    config_contents += "name = 'frozen'\n\n"
    config_contents += 'translation_map = {tmap_config}'

    config_contents = config_contents.format(
        tmap_config=pprint.pformat(get_frozen_translation_map(apps=apps)))

    translation_map_path = os.path.join(dest_dir, 'translation_map.py')
    with open(translation_map_path, 'w') as wfh:
        wfh.write(config_contents)

    return translation_map_path


def get_builtin_translation_config_path(name):
    '''
    Helper routine to get the full path to a builtin named translation config
    '''
    path_result = os.path.join(
        os.path.dirname(__file__),
        'config',
        name,
        'translation_map.py'
    )

    if not os.path.isfile(path_result):
        LOG.warning('config not found on filesystem: {}'.format(path_result))

    return path_result


def _init_translation_config():
    '''
    Initialize translation maps from env. variable search path. Cache in-process
    '''

    global TRANSLATION_CONFIG

    LOG.log(9, 'resetting translation config')
    TRANSLATION_CONFIG = []

    def _validate_all(*args, **kwargs):
        return True

    translation_map_path = os.getenv('SC_TRANSLATION_MAP_PATH', '').split(os.pathsep) 
    LOG.log(9, 'Loading translation config from env: {}'.format(translation_map_path))

    for tmap_dir_entry in translation_map_path:

        if not tmap_dir_entry:
            continue

        tmap_file = os.path.join(tmap_dir_entry, 'translation_map.py')
        locals_context = {
            'pathutil': pathutil,
            'translation_map': [],
            'validate': _validate_all,
            'enabled': True
        }

        try:
            LOG.log(9, 'attempting to load: {}'.format(tmap_file))

            exec(open(tmap_file).read(), {}, locals_context)

            TRANSLATION_CONFIG.append(TranslationConfig(
                locals_context['name'],
                locals_context['translation_map'],
                locals_context['validate'],
                locals_context['enabled']
            ))

        except:
            LOG.warning(traceback.format_exc())


    if not TRANSLATION_CONFIG:
        LOG.warning('no translation config loaded!')

    # Load state from environment, if specified
    #
    translation_map_state = os.getenv('SC_TRANSLATION_STATE', '')
    for tmap_state_setting in translation_map_state.split(','):
        tmap_state_result = tmap_state_setting.split('=')
        if len(tmap_state_result) == 2:
            tmap_config_label, tmap_enabled_state = tmap_state_result

            tmap_config_label = tmap_config_label.strip()
            tmap_enabled_state = tmap_enabled_state.strip()

            # support a whole translation map or just one of the entries via tmap.entry - e.g., local.apps
            #
            tmap_config_parts = tmap_config_label.split('.')
            tmap_config_name = tmap_config_parts[0]
            tmap_entry_name = None

            if len(tmap_config_parts) == 2:
                tmap_entry_name = tmap_config_parts[1]

            bool_val = pathutil.to_bool(tmap_enabled_state)

            set_config_enabled(tmap_config_name, tmap_entry_name, bool_val)

