#
# Copyright 2014-2024 Justin Ottley
#
# Licensed under the terms set forth in the LICENSE.txt file
#

import os
import logging
import tempfile

from . import EnvGenerator


class WindowsEnvGenerator(EnvGenerator):

    SC_TEMP_DIR = os.path.join(tempfile.gettempdir(), os.getenv('USER', os.getenv('USERNAME')), 'sc')

    def _generate_env(self, environ, result, messages=None):


        for logrecord in messages:
            if logrecord.levelname == 'INFO':
                if not logrecord.msg:
                    # windows doesnt like a blank echo line
                    logrecord.msg = '-'

                result += '''echo "{msg}"\n'''.format(msg=logrecord.msg)

            else:
                result += '''echo {name:28} [ {levelname} ] : "{msg}"\n'''.format(
                    name=logrecord.name,
                    levelname=logrecord.levelname,
                    msg=logrecord.msg)



        for env_entry, env_value in environ.items():
            
            # we're assuming bash as the shell
            result += 'set "{env_name}={env_value}"\n'.format(
                env_name=env_entry, env_value=env_value)


        return result


    def generate_env(self, messages=None):

        self.LOG.info('WindowsEnvGenerator: generate_env()')

        if messages is None:
            messages = []

        file_contents = ''

        file_contents = '@REM Automatically generated by scaffold.vc\n'
        file_contents += '@echo off\n'
        file_contents += 'SETLOCAL\n'

        file_contents += self._generate_env(
            self.compile_env(),
            '',
            messages)

        return file_contents


    def generate_env_file(self, messages=None, extra_commands=None):

        if not os.path.isdir(self.SC_TEMP_DIR):
            os.makedirs(self.SC_TEMP_DIR)

        tempfd, temp_filename = tempfile.mkstemp(dir=self.SC_TEMP_DIR, suffix='.bat')

        file_contents = self.generate_env(messages)
        file_contents += 'echo {f}\n'.format(f=temp_filename)

        if extra_commands:
            file_contents += extra_commands
            file_contents += '\n'

        file_contents += 'ENDLOCAL\n'

        # we're going to write to the same filename every time, cause windows .bat
        # can't really handle the complexity of output redirection and sourcing.
        # Go Windows, you stupid ass OS. Maybe switch to PowerShell?
        #



        # temp_filename = os.path.join(self.SC_TEMP_DIR, 'vc_env.bat')
        os.write(tempfd, bytes(file_contents, 'utf8'))
        os.close(tempfd)
        os.chmod(temp_filename, 0o0777)

        return temp_filename

