
import os
import json
import base64
import string
import random
import platform

import scaffold.variant

LOWERCASE_LETTERS = string.ascii_lowercase

import scaffold.buildsys.globals as buildsys_globals

from . import genfunc


def generate_pybind11_module(module_mode,
                             sset_rname,
                             modlib_name,
                             pb_info_str,
                             header_output_path,
                             ssc_header_output_path,
                             ssc_moc_output_path,
                             cpp_output_path,
                             source_headers,
                             source_moc_jsons):

    modlib_group = sset_rname.replace('Rlp', '').lower()

    lib_name = '{}{}module'.format(
        sset_rname,
        modlib_name
    )

    benv_pybind11_info = json.loads(base64.b64decode(pb_info_str).decode('utf-8'))

    pb_class_info = benv_pybind11_info['classes']
    pybind11_classes = benv_pybind11_info['classes'].keys()

    header_contents = '// Automatically generated by scninja\n\n'

    for class_shortname in pybind11_classes:
        
        if pb_class_info[class_shortname].get('register_typeconverter') is False:
            print('SKIPPING TYPE CONVERSION: {}'.format(class_shortname))
            continue

        header_name = class_shortname
        if 'header' in pb_class_info[class_shortname]:
            header_name = pb_class_info[class_shortname]['header']


        header_include = '{}/{}/{}.h'.format(sset_rname, modlib_name, header_name)
        print(header_include)
        header_contents += '#include "{}"\n'.format(header_include)

    header_contents += '#include "RlpCore/PY/PyQVariant.h"\n\n'
    header_contents += '#include "{}/{}/Global.h"\n\n'.format(sset_rname, modlib_name)


    header_contents += "\n\n"
    header_contents += 'void {}_{}_API {}_bootstrap();\n'.format(modlib_group.upper(), modlib_name, lib_name)

    class_prefix = benv_pybind11_info.get('lib_prefix') or modlib_name
    for class_shortname in pybind11_classes:

        if pb_class_info[class_shortname].get('register_typeconverter') is False:
            print('SKIPPING TYPE CONVERSION: {}'.format(class_shortname))
            continue

        class_name = '{}_{}'.format(class_prefix, class_shortname)

        class_ptr = '{}*'.format(class_name)

        ct =  'class {}_PyTypeConverter : public PyTypeConverter {{\n'.format(class_name)
        ct += '  public:\n\n'
        ct += '    {}_PyTypeConverter():\n'.format(class_name)
        ct += '        PyTypeConverter("{}")\n'.format(class_name)
        ct += '    {\n'
        ct += '    }\n\n'
        ct += '    py::object\n'
        ct += '    toPy(QVariant val)\n'
        ct += '    {\n'
        ct += '      return py::cast(val.value<{}>());\n'.format(class_ptr)
        ct += '    }\n\n'
        ct += '    QVariant\n'
        ct += '    fromPy(py::handle pobj)\n'
        ct += '    {\n'
        ct += '       {} cobj = pobj.cast<{}>();\n'.format(class_ptr, class_ptr)
        ct += '       QVariant result;\n'
        ct += '       result.setValue(cobj);\n'
        ct += '       return result;\n'
        ct += '    }\n'
        ct += '};\n\n'

        if pb_class_info[class_shortname].get('holder') == 'shared_ptr':
            print('BUILDING std::shared_ptr PyTypeConverter for {}'.format(class_shortname))

            class_ptr = 'std::shared_ptr<{}> '.format(class_name)

            ct +=  'class {}_SharedPtrPyTypeConverter : public PyTypeConverter {{\n'.format(class_name)
            ct += '  public:\n\n'
            ct += '    {}_SharedPtrPyTypeConverter():\n'.format(class_name)
            ct += '        PyTypeConverter("{}")\n'.format(class_name)
            ct += '    {\n'
            ct += '    }\n\n\n'
            ct += '    py::object\n'
            ct += '    toPy(QVariant val)\n'
            ct += '    {\n'
            ct += '      return py::cast(val.value<std::shared_ptr<{}> >());\n'.format(class_name)
            ct += '    }\n\n'
            ct += '    QVariant\n'
            ct += '    fromPy(py::handle pobj)\n'
            ct += '    {\n'
            ct += '       {} cobj = pobj.cast<{}>();\n'.format(class_ptr, class_ptr)
            ct += '       QVariant result;\n'
            ct += '       result.setValue(cobj);\n'
            ct += '       return result;\n'
            ct += '    }\n'
            ct += '};\n\n'

        header_contents += ct

    # print('')
    # print(header_contents)
    # print('')

    # header_output_path = target[0].get_abspath()
    header_output_dir = os.path.dirname(header_output_path)
    if not os.path.isdir(header_output_dir):
        print('Creating {}'.format(header_output_dir))
        os.makedirs(header_output_dir)

    with open(header_output_path, 'w') as wfh:
        wfh.write(header_contents)

    print('Wrote {}'.format(header_output_path))


    # -------------------------------------------------------------------------

    # generate PySigSlotConnectors
    #

    ssc = '// Automatically generated by scaffold\n\n'
    ssc += '#include "RlpCore/PY/PySignal.h"\n'
    ssc += '#include "RlpCore/PY/Interp.h"\n\n'

    for include_entry in benv_pybind11_info.get('includes', []):
        ssc += '#include "{}"\n'.format(include_entry)

    for src_json_path in source_moc_jsons:
    
        if os.path.isfile(src_json_path):
            print(src_json_path)
            with open(src_json_path) as fh:
                json_data = fh.read()
                if not json_data:
                    continue
                cls_info = json.loads(json_data)
                for class_entry in cls_info['classes']:


                    for signal_entry in class_entry.get('signals', []):
                        sig_args = signal_entry.get('arguments', [])

                        if len(sig_args) == 0:
                            continue

                        if len(sig_args) == 1 and sig_args[0]['type'] in ['int', 'bool', 'qlonglong', 'QString', 'QVariantMap']:
                            continue

                        signal_signature = '{}_{}_{}'.format(
                            class_entry['className'], signal_entry['name'],
                            '_'.join([n['type'] for n in sig_args])
                        )
                        signal_signature = signal_signature.replace('*', '_ptr')
                        sig_ok = True
                        for bad_char in ['&', '<', '>', ':']:
                            if bad_char in signal_signature:
                                sig_ok = False
                                break

                        if not sig_ok:
                            print('NOT SUPPORTED: {}'.format(signal_signature))
                            continue

                        signal_key = '{}({})'.format(
                            signal_entry['name'],
                            ', '.join(['{} {}'.format(n['type'], n['name']) for n in sig_args])
                        )

                        print('SIGNAL SIGNATURE: {}'.format(signal_signature))

                        ssc += '\n\n'
                        ssc += 'class {}_PySigSlotConnector : public PySigSlotConnector\n'.format(signal_signature)
                        ssc += '{\n'
                        ssc += '  Q_OBJECT\n\n'
                        ssc += 'public:\n'
                        ssc += '  {}_PySigSlotConnector():\n'.format(signal_signature)
                        ssc += '    PySigSlotConnector()\n'
                        ssc += '  {\n'
                        ssc += '  }\n\n'
                        ssc += 'public slots:\n'
                        ssc += '  void slot_{}\n'.format(signal_key)
                        ssc += '  {\n'

                        ssc += '    PY_Interp::acquireGIL();\n'
                        arg_idx = 0
                        for arg in sig_args:
                            ssc += '    py::object pobj{} = py::cast({});\n'.format(arg_idx, arg['name'])
                            arg_idx += 1
        
                        ssc += '    for (auto pslot : _pyslots)\n'
                        ssc += '    {\n'
                        ssc += '      if (pslot != nullptr)\n'
                        ssc += '      {\n'
                        ssc += '        pslot('

                        carg_list = []
                        arg_idx = 0
                        for arg in sig_args:
                            carg_list.append('pobj{}'.format(arg_idx))
                            arg_idx += 1

                        ssc += ', '.join(carg_list)
                        ssc += ');\n'

                        ssc += '      }\n'
                        ssc += '    }\n'
                        ssc += '  }\n'
                        ssc += '};\n'

                        # print('-------------')
                        # print(ssc)
                        # print('-------------')

    
    with open(ssc_header_output_path, 'w') as wfh:
        wfh.write(ssc)

    # ssc_moc_output_path = ssc_header_output_path.replace('.h', '.cpp')

    print('Wrote {}'.format(ssc_header_output_path))
    qt_root_dir = os.path.join(
        buildsys_globals.senv_config['dir.thirdbase'],
        'Qt',
        buildsys_globals.senv_config['qt_version'],
    )
    
    moc_exec = os.path.join(qt_root_dir, 'gcc_64', 'libexec', 'moc')
    if os.name == 'nt':
        moc_exec = os.path.join(qt_root_dir, 'bin', 'moc.exe')
    
    if platform.system() == 'Darwin':
        moc_exec = os.path.join(qt_root_dir, 'macos', 'libexec', 'moc')

    if scaffold.variant.get_variant('arch') == 'aarch64':
        moc_exec = '{}/lib/qt6/moc'.format(os.getenv('PREFIX'))
        
    print('running moc: {}'.format(moc_exec))
    moc_cmd = '{} -o {} {}'.format(moc_exec, ssc_moc_output_path, ssc_header_output_path)
    print(moc_cmd)
    os.system(moc_cmd)


    pybind11_info = benv_pybind11_info
    pybind11_classes = pybind11_info['classes'].keys()

    print('PYBIND11 CLASSES:')
    print(pybind11_classes)
    print('')


    t = '// Automatically generated by scaffold\n\n'
    t += '#include <pybind11/pybind11.h>\n'
    t += '#include <pybind11/embed.h>\n\n'

    for header_entry in source_headers:
        header_filename = os.path.basename(header_entry)
        if not header_filename.endswith('.h'):
            # no more headers
            break

        # src_idx += 1

        if header_filename.replace('.h', '') not in pybind11_classes:
            continue

        header_include = '{}/{}/{}'.format(sset_rname, modlib_name, header_filename)
        print(header_include)
        t += '#include "{}"\n'.format(header_include)

    for include_entry in pybind11_info.get('includes', []):
        t += '#include "{}"\n'.format(include_entry)


    t += '#include "{}/{}/pymodule.h"\n\n'.format(
        sset_rname, modlib_name
    )
    t += '#include "{}/{}/pysigslot.h"\n\n'.format(
        sset_rname, modlib_name
    )
    t += '#include "RlpCore/PY/PyQVariant.h"\n\n'
    t += '#include "RlpCore/PY/PySignal.h"\n'
    t += '#include "RlpCore/PY/Interp.h"\n'
    t += '\nnamespace py = pybind11;\n\n'
    t += 'RLP_SETUP_MODULE_LOGGER({}, {})\n\n'.format(modlib_group, modlib_name)
    t += 'void {}_bootstrap() {{\n'.format(lib_name)
    t += '  RLP_LOG_DEBUG_MODULE({}, {}, "")\n\n'.format(modlib_group, modlib_name)

    ti = 'void {}_initmodule() {{\n'.format(lib_name)
    ti += '  RLP_LOG_DEBUG_MODULE({}, {}, "")\n\n'.format(modlib_group, modlib_name)
    
    if module_mode == 'dynamic':
        ti += '  {}_bootstrap();\n'.format(lib_name)

    for class_shortname in pybind11_classes:

        class_name = '{}_{}'.format(class_prefix, class_shortname)

        if pb_class_info[class_shortname].get('bootstrap'):

            cls_bootstrap_info = pb_class_info[class_shortname]['bootstrap']

            print('OBJECT BOOTSTRAP: {}'.format(class_name))
            print(cls_bootstrap_info)

            if 'bind_object' in cls_bootstrap_info:
                
                bind_object_name = cls_bootstrap_info['bind_object']
                if bind_object_name is True: # shortcut to use upperclase class name as name of object
                    bind_object_name = class_name.upper()


                cls_var = ''.join(random.choice(LOWERCASE_LETTERS) for i in range(4))
                cls_bind = '  {}* {} = new {}();\n'.format(class_name, cls_var, class_name)
                cls_bind += '  RLP_LOG_DEBUG_MODULE({}, {}, "Instantiated" << {})\n'.format(modlib_group, modlib_name, cls_var)
                cls_bind += '  PY_Interp::bindAppObject("{}", "{}_OBJ", {});\n'.format(
                    lib_name, bind_object_name, cls_var
                )

                ti += cls_bind
                ti += '\n\n'


        if pb_class_info[class_shortname].get('register_typeconverter') is not False:

            print('REGISTERING TYPECONVERTER FOR {}'.format(class_name))

            t += '  PyQVariant::registerConverter("{}*", new {}_PyTypeConverter());\n'.format(
                class_name, class_name
            )

            if pb_class_info[class_shortname].get('holder') == 'shared_ptr':
                print('REGISTERING std::shared_ptr TYPECONVERTER FOR {}'.format(class_name))

                t += '  PyQVariant::registerConverter("std::shared_ptr<{}>", new {}_SharedPtrPyTypeConverter());\n'.format(
                    class_name, class_name
                )

    for src_json_path in source_moc_jsons:

        if os.path.isfile(src_json_path):
            with open(src_json_path) as fh:
                json_data = fh.read()
                if not json_data:
                    continue
                cls_info = json.loads(json_data)
                for class_entry in cls_info['classes']:
                    
                    # print(class_entry)
                    # print('~~~~~~~~~~~~~~~~~~')

                    for signal_entry in class_entry.get('signals', []):
                        sig_args = signal_entry.get('arguments', [])
                        if len(sig_args) == 0:
                            continue
                        
                        # technically built-in support and does not require connector?
                        if len(sig_args) == 1 and sig_args[0]['type'] in ['int', 'bool', 'qlonglong', 'QString', 'QVariantMap']:
                            continue

                        signal_signature = '{}_{}_{}'.format(
                            class_entry['className'], signal_entry['name'],
                            '_'.join([n['type'] for n in sig_args])
                        )
                        signal_signature = signal_signature.replace('*', '_ptr')
                        sig_ok = True
                        for bad_char in ['&', '<', '>', ':']:
                            if bad_char in signal_signature:
                                sig_ok = False
                                break

                        if not sig_ok:
                            print('NOT SUPPORTED: {}'.format(signal_signature))
                            continue

                        signal_key = '{}_{}({})'.format(
                            class_entry['className'], signal_entry['name'],
                            ', '.join([n['type'] for n in sig_args])
                        )

                        t += '  PySignal::registerConnector("{}", new {}_PySigSlotConnector());\n'.format(
                            signal_key, signal_signature
                        )


    t += '}\n\n'
    ti += '}\n\n'
    t += ti
    

    if module_mode == 'static':
        t += 'PYBIND11_EMBEDDED_MODULE({}, m) {{\n\n'.format(lib_name)
    else:
        t += 'PYBIND11_MODULE({}, m) {{\n\n'.format(lib_name)

    t += '  m.def("init_module", &{}_initmodule, "Bootstrap Python Bindings");\n\n'.format(lib_name)

    for src_json_path in source_moc_jsons:
        
        if os.path.isfile(src_json_path):
            print(src_json_path)
            with open(src_json_path) as fh:
                json_data = fh.read()
                if not json_data:
                    continue
                cls_info = json.loads(json_data)
                for class_entry in cls_info['classes']:

                    _seen_slots = set()
                    class_name = class_entry['className']
                    class_lib_prefix = modlib_name + '_'
                    if 'lib_prefix' in benv_pybind11_info:
                        class_lib_prefix = benv_pybind11_info['lib_prefix'] + '_'

                    class_name_short = class_name.replace(class_lib_prefix, '')

                    if class_name_short not in pybind11_classes:
                        print('pybind11: SKIPPING: {}'.format(class_name_short))
                        continue

                    ctor_name = 'new_{}'.format(class_name)

                    pb_class_info = pybind11_info['classes'][class_name_short]
                    pb_class_slot_info = pb_class_info.get('slots', {})
                    #
                    # see if we need a std::shared_ptr holder or not
                    #
                    if 'holder' in pb_class_info:
                        parent_entry = ''
                        if 'parent' in pb_class_info:
                            parent_entry = '{} /* parent */ , '.format(pb_class_info['parent'])

                        t += '  py::class_<{}, {} std::shared_ptr<{}> >(m, "{}")\n'.format(
                            class_name, parent_entry, class_name, class_name
                        )

                    elif 'trampoline' in pb_class_info:
                        trampoline_name = pb_class_info['trampoline']

                        t += '  py::class_<{}, {} /* trampoline */ >(m, "{}")\n'.format(
                            class_name, trampoline_name, class_name
                        )
                    
                    elif 'parent' in pb_class_info:
                        parent_name = pb_class_info['parent']

                        t += '  py::class_<{}, {} /* parent */ >(m, "{}")\n'.format(
                            class_name, parent_name, class_name
                        )

                    else:
                        t += '  py::class_<{}>(m, "{}")\n'.format(class_name, class_name)


                    # get overloaded methods
                    #
                    meth_overload_map = {}
                    for slot_entry in class_entry.get('slots', []):
                        slot_name = slot_entry['name']

                        if slot_name in meth_overload_map:
                            pass
                            # NOTE: method overload disabled due to compile problems with default arguments
                            # meth_overload_map[slot_name]['count'] += 1
                        else:
                            meth_overload_map[slot_name] = {
                                'seen': 0,
                                'count': 1
                            }


                    for slot_entry in class_entry.get('slots', []):
                        if slot_entry['access'] != 'public':
                            continue

                        slot_name = slot_entry['name']
                        if slot_name in _seen_slots:
                            continue

                        pb_slot_info = pb_class_slot_info.get(slot_name, {})

                        _seen_slots.add(slot_name)

                        if slot_name == ctor_name:
                            print('GOT CTOR: {}'.format(slot_name))

                            if 'trampoline' in pb_class_info:
                                t += '    .def(py::init_alias< ' # &{}::{}))\n'.format(class_name, slot_name)
                                for arg in slot_entry['arguments']:
                                    t += arg['type']
                                    t += ' '

                                t += '>())\n'
                            else:

                                m = genfunc.Method.make(class_name, slot_entry, pb_slot_info)
                                t += m.gen()

                        else:
                            # print('GOT: {}::{}'.format(class_name, slot_name))
                            
                            retval_policy = pb_slot_info.get('return_value_policy')

                            if '*' in slot_entry['returnType']:
                                retval_policy = 'reference'


                            # NOTE: overload setup disabled due to compiling problems with default arguments
                            if pb_slot_info.get('fulldef'): # meth_overload_map[slot_name]['count'] > 1:
                                print('FULLDEF METHOD')

                                meth_overload_map[slot_name]['seen'] += 1

                                t += '    .def("{}",\n'.format(slot_name)

                                t += '         static_cast<{} ({}::*)('.format(slot_entry['returnType'], class_name)
                                t += ', '.join([arg['type'] for arg in slot_entry.get('arguments', [])])
                                t += ')>(&{}::{})\n'.format(class_name, slot_name)

                                if retval_policy:
                                    t += '         ,py::return_value_policy::{}\n'.format(retval_policy)

                                t += '    )\n'
                            else:

                                m = genfunc.Method.make(class_name, slot_entry, pb_slot_info)
                                t += m.gen()

                                

                    for signal_entry in class_entry.get('signals', []):

                        sig_args = signal_entry.get('arguments', [])
                        sig_arg_type = ", ".join([arg['type'] for arg in sig_args])

                        sig_name = signal_entry['name']

                        t += '    .def_property_readonly("{}",\n'.format(sig_name)
                        t += '        [](const {} &obj) {{\n'.format(class_name)
                        t += '            return new PySignal(&obj, "{}({})");\n'.format(sig_name, sig_arg_type)
                        t += '        }\n'
                        t += '     )\n'

                    t += '  ;\n\n'

    t += '}\n'

    # print('')
    # print(t)
    # print('')

    cpp_output_path = cpp_output_path
    with open(cpp_output_path, 'w') as wfh:
        wfh.write(t)
        print('Wrote {}'.format(cpp_output_path))



